package optic_fusion1.antimalwaretoolkit.tool.impl;

import java.io.File;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.List;
import java.util.stream.Collectors;

import org.jetbrains.annotations.Nullable;

import optic_fusion1.antimalwaretoolkit.configuration.ConfigurationSection;
import optic_fusion1.antimalwaretoolkit.configuration.file.FileConfiguration;
import optic_fusion1.antimalwaretoolkit.configuration.file.YamlConfiguration;
import optic_fusion1.antimalwaretoolkit.tool.Tool;

public class DatabaseMigration extends Tool {

	@Override
	public void run(String[] args) {
		try {
			Class.forName("org.sqlite.JDBC");
			try (Connection connection = DriverManager.getConnection("jdbc:sqlite:file:" + args[3])) {

				createMalwareCheckTables(connection);

				File databaseFile = new File(args[0]);
				FileConfiguration databaseConfig = YamlConfiguration.loadConfiguration(databaseFile);
				databaseConfig.getKeys(false).forEach((key) -> {
					try {
						insertMalwareChecks(connection, key, databaseConfig.getConfigurationSection(key));
					} catch (SQLException e) {
						e.printStackTrace();
					}
				});

				createMaliciousDevBansTables(connection);
				File bansFile = new File(args[1]);
				FileConfiguration bansConfig = YamlConfiguration.loadConfiguration(bansFile);
				bansConfig.getKeys(false).forEach((key) -> {
					try {
						insertBans(connection, key, bansConfig.getConfigurationSection(key));
					} catch (SQLException e) {
						e.printStackTrace();
					}
				});

				createWhitelistTables(connection);

				File whitelistFile = new File(args[2]);
				FileConfiguration whitelist = YamlConfiguration.loadConfiguration(whitelistFile);
				whitelist.getKeys(false).forEach((key) -> {
					try {
						insertWhitelist(connection, key, whitelist);
					} catch (SQLException e) {
						e.printStackTrace();
					}
				});
			} catch (SQLException sql) {
				sql.printStackTrace();
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	public String getDescription() {
		return "Usage: databasemigration {database.yml} {banned-players.yml} {checksums.yml} {database.db}";
	}

	private void insertWhitelist(Connection connection, String key, FileConfiguration config) throws SQLException {
		if (config.isConfigurationSection(key)) {
			config.getConfigurationSection(key).getKeys(false).forEach((subKey) -> {
				List list = config.getList(key + "." + subKey);
				if (list == null) {
					System.out.println("ERROR: " + key + "." + subKey);
					return;
				}
				if (list.size() > 0 && list.get(0) instanceof List) {
					list = (List) ((List<List>) list).stream().flatMap(List::stream).collect(Collectors.toList());
				}
				try {
					insertWhitelistEntries(connection, key, subKey, list);
				} catch (SQLException e) {
					e.printStackTrace();
				}
			});
		} else {
			List list = (List<List<String>>) config.getList(key);
			if (list.size() > 0 && list.get(0) instanceof List) {
				list = (List) ((List<List>) list).stream().flatMap(List::stream).collect(Collectors.toList());
			}
			insertWhitelistEntries(connection, key, key, list);
		}
	}

	final String insertWhitelistPlugin = "INSERT OR IGNORE INTO WhitelistedPlugins ('Name', 'Author') VALUES (?, ?);";
	final String getWhitelistPluginID = "SELECT _rowid_ FROM WhitelistedPlugins WHERE Name = ? AND Author = ?;";
	final String insertWhitelistChecksum = "INSERT OR IGNORE INTO WhitelistedChecksums ('Checksum','WhitelistedPlugin') VALUES (?, ?);";

	private void insertWhitelistEntries(Connection connection, String author, String pluginName, List<String> checksums)
			throws SQLException {
		PreparedStatement pSt = connection.prepareStatement(insertWhitelistPlugin);
		pSt.setString(1, pluginName);
		pSt.setString(2, author);
		pSt.executeUpdate();

		int pluginID = getWhitelistPluginID(connection, author, pluginName);

		pSt = connection.prepareStatement(insertWhitelistChecksum);
		for (String checksum : checksums) {
			pSt.setString(1, checksum);
			pSt.setInt(2, pluginID);
			pSt.executeUpdate();
		}
	}

	private int getWhitelistPluginID(Connection connection, String author, String pluginName) throws SQLException {
		PreparedStatement pSt = connection.prepareStatement(getWhitelistPluginID);
		pSt.setString(1, pluginName);
		pSt.setString(2, author);
		ResultSet rs = pSt.executeQuery();
		if (rs.next()) {
			return rs.getInt("rowid");
		}
		return -1;
	}

	private void createWhitelistTables(Connection connection) throws SQLException {
		connection.prepareStatement(
				"CREATE TABLE IF NOT EXISTS \"WhitelistedPlugins\" (\n" + "	\"Name\"	TEXT NOT NULL,\n"
						+ "	\"Author\"	TEXT NOT NULL,\n" + "	\"ResourceID\"	TEXT, UNIQUE(Name, Author)\n" + ")")
				.execute();

		connection.prepareStatement("CREATE TABLE IF NOT EXISTS \"WhitelistedChecksums\" (\n"
				+ "	\"Checksum\"	TEXT NOT NULL UNIQUE,\n" + "	\"WhitelistedPlugin\"	INTEGER NOT NULL\n" + ")")
				.execute();
	}

	final String insertMaliciousDev = "INSERT OR IGNORE INTO BannedAuthors ('Name') VALUES (?);";
	final String insertPreviousName = "INSERT OR IGNORE INTO BannedAuthorsNames ('Name', 'AuthorID') VALUES (?, ?);";
	final String insertUUID = "INSERT OR IGNORE INTO BannedAuthorsUUIDs ('UUID', 'AuthorID') VALUES (?, ?);";

	private void insertBans(Connection connection, String key, @Nullable ConfigurationSection configurationSection)
			throws SQLException {
		PreparedStatement pSt = connection.prepareStatement(insertMaliciousDev);
		pSt.setString(1, key);
		pSt.executeUpdate();

		int authorID = getMaliciousDevID(connection, key);

		if (configurationSection.contains("previous-names")) {
			pSt = connection.prepareStatement(insertPreviousName);
			if (configurationSection.isList("previous-names")) {
				for (String previousName : configurationSection.getStringList("previous-names")) {
					pSt.setString(1, previousName);
					pSt.setInt(2, authorID);
					pSt.executeUpdate();
				}
				pSt.close();
			} else {
				pSt.setString(1, configurationSection.getString("previous-names"));
				pSt.setInt(2, authorID);
				pSt.executeUpdate();
				pSt.close();
			}
		}

		if (configurationSection.contains("uuid")) {
			pSt = connection.prepareStatement(insertUUID);
			if (configurationSection.isList("uuid")) {
				for (String previousName : configurationSection.getStringList("uuid")) {
					pSt.setString(1, previousName);
					pSt.setInt(2, authorID);
					pSt.executeUpdate();
				}
				pSt.close();
			} else {
				pSt.setString(1, configurationSection.getString("uuid"));
				pSt.setInt(2, authorID);
				pSt.executeUpdate();
			}
			pSt.close();
		}
	}

	private int getMaliciousDevID(Connection connection, String name) throws SQLException {
		PreparedStatement pSt = connection.prepareStatement("SELECT _rowid_ FROM BannedAuthors WHERE Name = ?");
		pSt.setString(1, name);
		ResultSet rs = pSt.executeQuery();
		if (rs.next()) {
			return rs.getInt("rowid");
		}
		return -1;
	}

	private void createMaliciousDevBansTables(Connection connection) throws SQLException {
		connection.prepareStatement(
				"CREATE TABLE IF NOT EXISTS \"BannedAuthors\" (\n" + "	\"Name\"	TEXT NOT NULL UNIQUE\n" + ")")
				.execute();

		connection.prepareStatement(
				"CREATE TABLE IF NOT EXISTS \"BannedAuthorsNames\" (\n" + "	\"Name\"	TEXT NOT NULL,\n"
						+ "	\"AuthorID\"	INTEGER NOT NULL, UNIQUE(Name, AuthorID)\n" + ")")
				.execute();

		connection.prepareStatement(
				"CREATE TABLE IF NOT EXISTS \"BannedAuthorsUUIDs\" (\n" + "	\"UUID\"	TEXT NOT NULL,\n"
						+ "	\"AuthorID\"	INTEGER NOT NULL, UNIQUE(UUID, AuthorID)\n" + ")")
				.execute();
	}

	final String insertMalwareCheckName = "INSERT OR IGNORE INTO MalwareChecks ('family', 'firstFoundDate') VALUES (?, date());";
	final String insertBlacklistedAuthor = "INSERT OR IGNORE INTO BlacklistedAuthors ('Name', 'MalwareID') VALUES (?, ?);";
	final String insertBlacklistedChecksum = "INSERT OR IGNORE INTO BlacklistedChecksums ('Checksum', 'MalwareID') VALUES (?, ?);";
	final String insertBlacklistedClasspath = "INSERT OR IGNORE INTO BlacklistedClasspaths ('Classpath', 'MalwareID') VALUES (?, ?);";
	final String insertBlacklistedStrings = "INSERT OR IGNORE INTO BlacklistedStrings ('String', 'MalwareID') VALUES (?, ?);";

	private void insertMalwareChecks(Connection connection, String key,
			@Nullable ConfigurationSection configurationSection) throws SQLException {
		if (configurationSection == null)
			return;
		PreparedStatement pSt = connection.prepareStatement(insertMalwareCheckName);
		pSt.setString(1, key);
		pSt.executeUpdate();

		int malwareID = getMalwareCheckRowID(connection, key);

		if (configurationSection.contains("blacklisted-authors")) {
			for (String author : configurationSection.getStringList("blacklisted-authors")) {
				pSt = connection.prepareStatement(insertBlacklistedAuthor);
				pSt.setString(1, author);
				pSt.setInt(2, malwareID);
				pSt.executeUpdate();
			}
		}

		if (configurationSection.contains("blacklisted-checksums")) {
			for (String checksum : configurationSection.getStringList("blacklisted-checksums")) {
				pSt = connection.prepareStatement(insertBlacklistedChecksum);
				pSt.setString(1, checksum);
				pSt.setInt(2, malwareID);
				pSt.executeUpdate();
			}
		}

		if (configurationSection.contains("blacklisted-classpaths")) {
			for (String classpath : configurationSection.getStringList("blacklisted-classpaths")) {
				pSt = connection.prepareStatement(insertBlacklistedClasspath);
				pSt.setString(1, classpath);
				pSt.setInt(2, malwareID);
				pSt.executeUpdate();
			}
		}

		if (configurationSection.contains("blacklisted-strings")) {
			for (String string : configurationSection.getStringList("blacklisted-strings")) {
				pSt = connection.prepareStatement(insertBlacklistedStrings);
				pSt.setString(1, string);
				pSt.setInt(2, malwareID);
				pSt.executeUpdate();
			}
		}
	}

	private int getMalwareCheckRowID(Connection connection, String name) throws SQLException {
		PreparedStatement pSt = connection
				.prepareStatement("SELECT _rowid_ FROM MalwareChecks WHERE platform = \"Java\" AND family = ?");
		pSt.setString(1, name);
		ResultSet rs = pSt.executeQuery();
		if (rs.next()) {
			return rs.getInt("rowid");
		}
		return -1;
	}

	private void createMalwareCheckTables(Connection connection) throws SQLException {
		connection.prepareStatement(
				"CREATE TABLE IF NOT EXISTS \"MalwareChecks\" (\n" + "	\"type\"	TEXT NOT NULL DEFAULT 'MALWARE',\n"
						+ "	\"platform\"	TEXT NOT NULL DEFAULT 'Java',\n" + "	\"family\"	TEXT NOT NULL UNIQUE,\n"
						+ "	\"variant\"	TEXT NOT NULL DEFAULT 'A',\n" + "	\"firstFoundDate\"	TEXT NOT NULL,\n"
						+ "	\"otherInfo\"	TEXT,\n" + "	PRIMARY KEY(\"family\")\n" + ")")
				.execute();

		connection
				.prepareStatement("CREATE TABLE IF NOT EXISTS \"BlacklistedStrings\" (\n"
						+ "	\"String\"	TEXT NOT NULL UNIQUE,\n" + "	\"MalwareID\"	INTEGER NOT NULL\n" + ")")
				.execute();

		connection
				.prepareStatement("CREATE TABLE IF NOT EXISTS \"BlacklistedClasspaths\" (\n"
						+ "	\"Classpath\"	TEXT NOT NULL UNIQUE,\n" + "	\"MalwareID\"	INTEGER NOT NULL\n" + ")")
				.execute();

		connection
				.prepareStatement("CREATE TABLE IF NOT EXISTS \"BlacklistedChecksums\" (\n"
						+ "	\"Checksum\"	TEXT NOT NULL UNIQUE,\n" + "	\"MalwareID\"	INTEGER NOT NULL\n" + ")")
				.execute();

		connection
				.prepareStatement("CREATE TABLE IF NOT EXISTS \"BlacklistedAuthors\" (\n"
						+ "	\"Name\"	TEXT NOT NULL UNIQUE,\n" + "	\"MalwareID\"	INTEGER NOT NULL\n" + ")")
				.execute();
	}

}
