package optic_fusion1.antimalwaretoolkit.tool.impl;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.file.FileSystem;
import java.nio.file.FileSystemLoopException;
import java.nio.file.FileSystems;
import java.nio.file.FileVisitOption;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.StreamSupport;

import org.objectweb.asm.ClassReader;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.InvokeDynamicInsnNode;
import org.objectweb.asm.tree.LdcInsnNode;
import org.objectweb.asm.tree.MethodInsnNode;
import org.objectweb.asm.tree.MethodNode;

import optic_fusion1.antimalwaretoolkit.tool.Tool;

public class PluginAnalyzer extends Tool {

	boolean exportClassFiles;
	Map<Pattern, Integer> stringFilters;
	Map<Pattern, Integer> methodFilters;
	int foundPlugins = 0;

	@Override
	public void run(String[] args) {
		foundPlugins = 0;
		File toAnalyze = new File(args[0]);
		if (!toAnalyze.exists()) {
			System.out.println("The File " + args[0] + " doesn't exist!");
			return;
		}
		List<String> options = List.of(args);
		exportClassFiles = options.contains("-e");
		if (exportClassFiles) {
			new File("exportedClassFiles").mkdirs();
		}
		stringFilters = options.stream().filter((str) -> str.startsWith("-s")).map((str) -> str.substring(2))
				.collect(Collectors.toMap((str) -> Pattern.compile(str), (str) -> 0));
		methodFilters = options.stream().filter((method) -> method.startsWith("-m"))
				.map((method) -> method.substring(2))
				.collect(Collectors.toMap((method) -> Pattern.compile(method), (method) -> 0));

		if (toAnalyze.isDirectory()) {
			analyzeDirectory(toAnalyze.toPath());
		} else {
			analyzeFile(toAnalyze.toPath());
		}
		System.out.println("--- OVERVIEW ---");
		System.out.println(foundPlugins + " Plugins matched the Filters");
		System.out.println("--- StringFilters ---");
		for (Pattern p : stringFilters.keySet()) {
			System.out.println(p.toString() + ": " + stringFilters.get(p));
		}
		System.out.println("--- MethodFilters ---");
		for (Pattern p : methodFilters.keySet()) {
			System.out.println(p.toString() + ": " + methodFilters.get(p));
		}
	}

	private void analyzeDirectory(Path toAnalyze) {
		try {
			Files.list(toAnalyze).forEach(this::analyzeFile);
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	private void analyzeFile(Path file) {
		if (file.getFileName().toString().endsWith(".zip")) {
			analyzeZip(file);
			return;
		} else if (file.getFileName().toString().endsWith(".jar")) {
			try (FileSystem fs = FileSystems.newFileSystem(file, null)) {
				boolean matched = StreamSupport.stream(fs.getRootDirectories().spliterator(), false).anyMatch((dir) -> {
					try {
						return scanInnerDirectory(dir, file);
					} catch (Exception e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					return false;
				});
				if (matched) {
					foundPlugins++;
				}
			} catch (FileSystemLoopException loop) {
				loop.printStackTrace();
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
	}

	private boolean scanInnerDirectory(Path dir, Path outerFile) {
		try {
			return Files.list(dir).anyMatch((path) -> {
				if (!Files.isSymbolicLink(path)) {
					if (Files.isDirectory(path)) {
						return scanInnerDirectory(path, outerFile);
					} else {
						return analyzeInnerFile(dir, outerFile);
					}
				}
				return false;
			});
		} catch (IOException e) {
			e.printStackTrace();
		}
		return false;
	}

	private boolean analyzeInnerFile(Path path, Path outerFile) {
		if (path != null && path.getFileName() != null) {
			if (path.getFileName().toString().endsWith(".class")) {
				try {
					ClassReader cr = new ClassReader(Files.newInputStream(path));
					ClassNode classNode = new ClassNode();
					cr.accept(classNode, 0);
					boolean strings = searchForStrings(path, classNode);
					boolean methods = searchForMethods(path, classNode);
					if (strings && methods) {
						System.out.println("[FOUND] Class " + classNode.name + " in File "
								+ outerFile.toAbsolutePath().toString() + " matches!");
						if (exportClassFiles) {
							new File("exportedClassFiles/" + outerFile.getFileName().toString()).mkdirs();
							Files.copy(path, new FileOutputStream("exportedClassFiles/"
									+ outerFile.getFileName().toString() + "/" + path.getFileName().toString()));
						}
						return true;
					}
				} catch (Exception e) {
					System.out.println("ERROR " + e.getMessage() + " " + path.toString());
				}
			}
		}
		return false;
	}

	private boolean searchForStrings(Path path, ClassNode classNode) {
		if (stringFilters.isEmpty())
			return true;
		List<String> strings = new ArrayList<>();
		for (MethodNode methodNode : classNode.methods) {
			for (AbstractInsnNode insnNode : methodNode.instructions.toArray()) {
				if (insnNode instanceof LdcInsnNode && ((LdcInsnNode) insnNode).cst instanceof String) {
					String str = (String) ((LdcInsnNode) insnNode).cst;
					strings.add(str);
				}
			}
		}
		Map<Pattern, Integer> stringFiltersCopy = new HashMap<Pattern, Integer>(stringFilters);
		long count = strings.stream().flatMap((str) -> stringFilters.keySet().stream().filter((pat) -> {
			if (pat.matcher(str).find()) {
				stringFiltersCopy.put(pat, stringFiltersCopy.get(pat) + 1);
				return true;
			}
			return false;
		})).distinct().count();
		stringFilters = stringFiltersCopy;
		return stringFilters.size() == count;
	}

	private boolean searchForMethods(Path path, ClassNode classNode) {
		if (methodFilters.isEmpty())
			return true;
		List<String> methods = new ArrayList<>();
		for (MethodNode methodNode : classNode.methods) {
			for (AbstractInsnNode insnNode : methodNode.instructions.toArray()) {
				if (insnNode instanceof MethodInsnNode) {
					String str = ((MethodInsnNode) insnNode).owner + "#" + ((MethodInsnNode) insnNode).name
							+ ((MethodInsnNode) insnNode).desc;
					if (str.length() > 1000) {
						System.out.println(
								"Class " + path.toAbsolutePath().toString() + " contains ultra long Method: " + str);
					}
					methods.add(str);
					if (methods.size() == 5000) {
						System.out.println("Class " + path.toAbsolutePath().toString() + " has over 5000 methods!");
					}
				} else if (insnNode instanceof InvokeDynamicInsnNode) {
					String str = ((InvokeDynamicInsnNode) insnNode).name + ((InvokeDynamicInsnNode) insnNode).desc;
					methods.add(str);
				}
			}
		}
		Map<Pattern, Integer> methodFiltersCopy = new HashMap<Pattern, Integer>(methodFilters);
		long count = methods.stream().flatMap((str) -> methodFilters.keySet().stream().filter((pat) -> {
			if (pat.matcher(str).find()) {
				methodFiltersCopy.put(pat, methodFiltersCopy.get(pat) + 1);
				return true;
			}
			return false;
		})).distinct().count();
		methodFilters = methodFiltersCopy;
		return methodFilters.size() == count;
	}

	private void analyzeZip(Path file) {
		try (FileSystem fs = FileSystems.newFileSystem(file, null)) {
			fs.getRootDirectories().forEach(this::analyzeDirectory);
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	public String getDescription() {
		return "Allows analyzing Single/Multiple Plugins by searching for certain Structures\n" + "Options: \n"
				+ "  ExportClassFiles: -e\n" + "  FilterForString: -s{STRING}\n" + "  FilterForMethod: -m{METHOD}";
	}

}
